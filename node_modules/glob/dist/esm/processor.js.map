oInformações pessoais eliminadasInformações básicas eliminadasAs informações personalizadas foram eliminadasEditar informações pessoaisEditar informações básicasNão guardadoData de nascimentoDiaMêsAnoDia de Nascimento $1Mês de Nascimento $1Ano de Nascimento $1Dia não selecionadoMês não selecionadoAno não selecionadoDia reiniciado devido a Data de nascimento inválidaMês reiniciado devido a Data de nascimento inválidaMostrar maisMostrar menosNome PróprioNome do MeioApelidoEditar na conta MicrosoftGerir na conta MicrosoftEliminar este cartãoEste cartão será removido do seu dispositivo, mas ainda pode ser utilizado com a autenticação de dois passos uma vez que está guardado na suaConta MicrosoftConta Microsoft.Guardar cartão na conta Microsoft(opcional)Detalhes do cartãoGuardado na conta MicrosoftDetalhes da prestaçãoPrestaçõesVeja a sua compra agora, pague depois em prestaçõesAlcunhaNovo cartão adicionado$1 eliminadoCartão de crédito editado$1 gravado na conta MicrosoftOcorreu um erro ao adicionar o cartão de crédito ou débito. Verifique as informações do seu cartão e tente novamente.Falha ao guardar o cartão na sua conta Microsoft. Verifique as informações do seu cartão e tente novamente.Sincronizar agoraA guardarAtivar o Designer no Microsoft Edge para criar e partilhar automaticamente conteúdos visuaisVamos formatar imagens, gráficos e outros conteúdos apelativas e recomendar automaticamente designs que pode personalizar e partilharPlay Etree in Microsoft Edge.Show your tree protect earth DESC.Poupe tempo e dinheiro nas suas Compras no Microsoft Edge $1Vamos encontrar automaticamente os melhores preços na Web e ajudá-lo a finalizar as suas compras mais rapidamente.Ativar notificações de ComprasVamos encontrar automaticamente os melhores preços na Web e ajudá-lo a finalizar as suas compras mais rapidamente. A Microsoft irá recolher o histórico de navegação e o conteúdo da página para melhorar a experiência de compras fornecida pelos produtos da Microsoft.Poupe tempo e dinheiro com Compras no Microsoft EdgeO Microsoft Edge pode ajudá-lo ao longo do seu percurso de compras. Se ativar esta opção, as Compras no Microsoft Edge irão ajudá-lo a tomar as melhores decisões de compra. Se quiser desativar as notificações de redução de preço, clique em "Não me lembrar novamente" na notificação ou elimine o produto do seu histórico. Se estiver a fazer compras nos modos InPrivate ou Convidado, nunca será alertado de quaisquer itens anteriormente procurados. Se quiser desativar totalmente a funcionalidade Compras no Microsoft Edge, desative a funcionalidade.O Microsoft Edge ajuda-o a poupar tempo e dinheiro durante as compras online. Se ativar esta ação, o Microsoft Edge recolhe informações relacionadas com a sua atividade e experiência de compra para fornecer e melhorar este serviço. Os dados recolhidos incluem informações sobre a sua utilização e o desempenho da funcionalidade Compras do Microsoft Edge, informações sobre o histórico de navegação em sites de compras e informações extraídas do conteúdo da página, incluindo informações sobre o produto, carrinho e detalhes da transação.https://docs.microsoft.com/en-us/microsoft-edge/privacy-whitepaper/#shoppinghttps://go.microsoft.com/fwlink/?linkid=2194724Obtenha notificações de coisas relacionadas que pode explorar com DescobrirIremos mostrar-lhe recomendações sobre coisas que pode explorar, como destinos de viagem, meteorologia, receitas, cartões de viagens e muito maisMostrar oportunidades para suportar causas e organizações sem fins lucrativos que sejam do seu interesseIdentificaremos automaticamente quando os sites sem fins lucrativos que visitar podem ser apoiados com Microsoft Rewards Points ou doações em dinheiroMelhorar imagens no Microsoft EdgeAumente a nitidez das imagens e melhore a cor, o brilho e o contraste com a Super resolução para imagensMelhorar imagens no Microsoft Edge $1Esta definição permite-lhe decidir se o Microsoft Edge pode melhorar automaticamente as imagens para lhe mostrar imagens mais nítidas com melhor cor, iluminação e contraste. Esta é atualmente uma funcionalidade experimental, pelo que poderá ainda não estar disponível para si.O Microsoft Edge irá priorizar a melhoria das imagens neste site, mas nem todas as imagens no site serão melhoradas.Está satisfeito com o melhoramento da imagem?Obrigado!Ajude-nos a melhorar:As imagens têm demasiado brilhoAs imagens não parecem realistasPreciso de desativá-lo em sites específicosMelhorar ImagensUtilize a super resolução para melhorar a clareza, a nitidez, a iluminação e o contraste em imagens na Web. Os URLs de imagens serão enviados para a Microsoft para fornecer uma super resolução. Pode optar por utilizar melhorar imagens nos sites de que gosta.Melhorar imagens para todos os sitesSempre melhorar imagens para estes sitesNunca melhorar imagens para estes sitesInclua correspondências relacionadas em Encontrar na páginaQuando estar ativada, a sua pesquisa "Encontrar na página" e o conteúdo da página Web serão enviados para a Microsoft para ajudar a encontrar melhores resultados, incluindo sinónimos, ortografias alternativas e respostas a perguntasPermitir que o Microsoft Edge ajude a manter os seus separadores organizadosIremos oferecer sugestões sobre como organizar os seus separadores para que possa navegar facilmenteGuardar Imagens para favoritosVamos tirar a imagem dominante relacionada com um site guardado ou uma captura de ecrã da página para melhorar a sua experiência de favoritos. Podemos fazê-lo em segundo plano para atualizar os favoritos que não têm atualmente uma imagem associada.Guardar capturas de ecrã de sites para históricoIremos tirar capturas de ecrã dos sites que visita e guardá-las para que possa revisitar rapidamente os sites que pretende ao pairar sobre os resultados do seu histórico no hub de histórico.Mostrar hiperligações partilhadas do Microsoft 365 apps no históricoEncontre ligações que partilhou recentemente ou que foram partilhadas consigo no Teams, no Outlook e no outras aplicações do Microsoft 365 no HistóricoCorrigir palavras-passe divulgadasAtivar a funcionalidade Deteção de Fuga de Palavra-passe para descobrir se qualquer uma das suas palavras-passe foi encontrada numa violação de dadosAs fugas de palavras-passe podem ser assustadoras - estamos aqui para ajudarO Microsoft Edge detetou que atacantes maliciosos publicaram os nomes de utilizador e as palavras-passe apresentados abaixo na Web. Para manter as suas contas seguras, altere as palavras-passe para estes sites.$1Como isto funciona:Guardou as suas palavras-passe no Microsoft Edge.O Microsoft Edge verifica as palavras-passe divulgadas na Web.Alertamo-lo se descobrirmos que alguma das suas palavras-passe foi divulgada.Altere as palavras-passe abaixo para ajudar a proteger as suas contas.Alterar agora!Passo seguinteAlterar palavra-passe violadaPalavra-passe divulgada ignoradaPalavra-passe divulgada restauradaPalavra-passe guardada eliminadaSelecione a palavra-passe para $1 e $2?Selecionar todas as palavra-passe$1 foi removidoAlterar a seleção de conclusão automática?Introduza a palavra-passe primáriaAlterar a sua palavra-passe primáriaCriar palavra-passe primáriaPalavra-passe primária personalizada criadaPalavra-passe primária personalizada alteradaPalavra-passe primária personalizada removidaMínimo de quatro caracteres (por ex.: 123abc)A palavra-passe introduzida está incorreta. Tente novamente.Introduza, pelo menos, quatro caracteresCertifique-se de que as suas palavras-passe correspondem.Nota: a sua palavra-passe principal só será guardada neste dispositivo e não é partilhada com a Microsoft. Se estiver a utilizar vários dispositivos ou perfis, terá de utilizar uma palavra-passe primária separada para cada.Confirme a nova palavra-passe primáriaIntroduza uma nova palavra-passe primáriaIntroduza a palavra-passe principal atualÉ necessária uma palavra-passe principalPermitir que o Microsoft Edge guarde as suas palavra-passe e ajude a mantê-las segurasPCAAC,IAAI,EAAE,EAAE,QAAQ,CAAC,CAAA;aAC9C;SACF;IACH,CAAC;IAED,UAAU,CACR,CAAO,EACP,CAAW,EACX,IAAoB,EACpB,QAAiB;QAEjB,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC;YAAE,OAAM;QAC3B,IAAI,CAAC,IAAI,EAAE;YACT,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,EAAE,QAAQ,EAAE,KAAK,CAAC,CAAA;SACrC;aAAM;YACL,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,CAAA;SAC3B;IACH,CAAC;IAED,UAAU,CAAC,CAAO,EAAE,CAAS,EAAE,IAAoB,EAAE,QAAiB;QACpE,uBAAuB;QACvB,IAAI,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;YAAE,OAAM;QACzB,IAAI,CAAC,IAAI,EAAE;YACT,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,EAAE,QAAQ,EAAE,KAAK,CAAC,CAAA;SACrC;aAAM;YACL,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,CAAA;SAC3B;IACH,CAAC;CACF","sourcesContent":["// synchronous utility for filtering entries and calculating subwalks\n\nimport { GLOBSTAR, MMRegExp } from 'minimatch'\nimport { Path } from 'path-scurry'\nimport { MMPattern, Pattern } from './pattern.js'\nimport { GlobWalkerOpts } from './walker.js'\n\n/**\n * A cache of which patterns have been processed for a given Path\n */\nexport class HasWalkedCache {\n  store: Map<string, Set<string>>\n  constructor(store: Map<string, Set<string>> = new Map()) {\n    this.store = store\n  }\n  copy() {\n    return new HasWalkedCache(new Map(this.store))\n  }\n  hasWalked(target: Path, pattern: Pattern) {\n    return this.store.get(target.fullpath())?.has(pattern.globString())\n  }\n  storeWalked(target: Path, pattern: Pattern) {\n    const fullpath = target.fullpath()\n    const cached = this.store.get(fullpath)\n    if (cached) cached.add(pattern.globString())\n    else this.store.set(fullpath, new Set([pattern.globString()]))\n  }\n}\n\n/**\n * A record of which paths have been matched in a given walk step,\n * and whether they only are considered a match if they are a directory,\n * and whether their absolute or relative path should be returned.\n */\nexport class MatchRecord {\n  store: Map<Path, number> = new Map()\n  add(target: Path, absolute: boolean, ifDir: boolean) {\n    const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0)\n    const current = this.store.get(target)\n    this.store.set(target, current === undefined ? n : n & current)\n  }\n  // match, absolute, ifdir\n  entries(): [Path, boolean, boolean][] {\n    return [...this.store.entries()].map(([path, n]) => [\n      path,\n      !!(n & 2),\n      !!(n & 1),\n    ])\n  }\n}\n\n/**\n * A collection of patterns that must be processed in a subsequent step\n * for a given path.\n */\nexport class SubWalks {\n  store: Map<Path, Pattern[]> = new Map()\n  add(target: Path, pattern: Pattern) {\n    if (!target.canReaddir()) {\n      return\n    }\n    const subs = this.store.get(target)\n    if (subs) {\n      if (!subs.find(p => p.globString() === pattern.globString())) {\n        subs.push(pattern)\n      }\n    } else this.store.set(target, [pattern])\n  }\n  get(target: Path): Pattern[] {\n    const subs = this.store.get(target)\n    /* c8 ignore start */\n    if (!subs) {\n      throw new Error('attempting to walk unknown path')\n    }\n    /* c8 ignore stop */\n    return subs\n  }\n  entries(): [Path, Pattern[]][] {\n    return this.keys().map(k => [k, this.store.get(k) as Pattern[]])\n  }\n  keys(): Path[] {\n    return [...this.store.keys()].filter(t => t.canReaddir())\n  }\n}\n\n/**\n * The class that processes patterns for a given path.\n *\n * Handles child entry filtering, and determining whether a path's\n * directory contents must be read.\n */\nexport class Processor {\n  hasWalkedCache: HasWalkedCache\n  matches = new MatchRecord()\n  subwalks = new SubWalks()\n  patterns?: Pattern[]\n  follow: boolean\n  dot: boolean\n  opts: GlobWalkerOpts\n\n  constructor(opts: GlobWalkerOpts, hasWalkedCache?: HasWalkedCache) {\n    this.opts = opts\n    this.follow = !!opts.follow\n    this.dot = !!opts.dot\n    this.hasWalkedCache = hasWalkedCache\n      ? hasWalkedCache.copy()\n      : new HasWalkedCache()\n  }\n\n  processPatterns(target: Path, patterns: Pattern[]) {\n    this.patterns = patterns\n    const processingSet: [Path, Pattern][] = patterns.map(p => [target, p])\n\n    // map of paths to the magic-starting subwalks they need to walk\n    // first item in patterns is the filter\n\n    for (let [t, pattern] of processingSet) {\n      this.hasWalkedCache.storeWalked(t, pattern)\n\n      const root = pattern.root()\n      const absolute = pattern.isAbsolute() && this.opts.absolute !== false\n\n      // start absolute patterns at root\n      if (root) {\n        t = t.resolve(\n          root === '/' && this.opts.root !== undefined\n            ? this.opts.root\n            : root\n        )\n        const rest = pattern.rest()\n        if (!rest) {\n          this.matches.add(t, true, false)\n          continue\n        } else {\n          pattern = rest\n        }\n      }\n\n      if (t.isENOENT()) continue\n\n      let p: MMPattern\n      let rest: Pattern | null\n      let changed = false\n      while (\n        typeof (p = pattern.pattern()) === 'string' &&\n        (rest = pattern.rest())\n      ) {\n        const c = t.resolve(p)\n        t = c\n        pattern = rest\n        changed = true\n      }\n      p = pattern.pattern()\n      rest = pattern.rest()\n      if (changed) {\n        if (this.hasWalkedCache.hasWalked(t, pattern)) continue\n        this.hasWalkedCache.storeWalked(t, pattern)\n      }\n\n      // now we have either a final string for a known entry,\n      // more strings for an unknown entry,\n      // or a pattern starting with magic, mounted on t.\n      if (typeof p === 'string') {\n        // must not be final entry, otherwise we would have\n        // concatenated it earlier.\n        const ifDir = p === '..' || p === '' || p === '.'\n        this.matches.add(t.resolve(p), absolute, ifDir)\n        continue\n      } else if (p === GLOBSTAR) {\n        // if no rest, match and subwalk pattern\n        // if rest, process rest and subwalk pattern\n        // if it's a symlink, but we didn't get here by way of a\n        // globstar match (meaning it's the first time THIS globstar\n        // has traversed a symlink), then we follow it. Otherwise, stop.\n        if (\n          !t.isSymbolicLink() ||\n          this.follow ||\n          pattern.checkFollowGlobstar()\n        ) {\n          this.subwalks.add(t, pattern)\n        }\n        const rp = rest?.pattern()\n        const rrest = rest?.rest()\n        if (!rest || ((rp === '' || rp === '.') && !rrest)) {\n          // only HAS to be a dir if it ends in **/ or **/.\n          // but ending in ** will match files as well.\n          this.matches.add(t, absolute, rp === '' || rp === '.')\n        } else {\n          if (rp === '..') {\n            // this would mean you're matching **/.. at the fs root,\n            // and no thanks, I'm not gonna test that specific case.\n            /* c8 ignore start */\n            const tp = t.parent || t\n            /* c8 ignore stop */\n            if (!rrest) this.matches.add(tp, absolute, true)\n            else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {\n              this.subwalks.add(tp, rrest)\n            }\n          }\n        }\n      } else if (p instanceof RegExp) {\n        this.subwalks.add(t, pattern)\n      }\n    }\n\n    return this\n  }\n\n  subwalkTargets(): Path[] {\n    return this.subwalks.keys()\n  }\n\n  child() {\n    return new Processor(this.opts, this.hasWalkedCache)\n  }\n\n  // return a new Processor containing the subwalks for each\n  // child entry, and a set of matches, and\n  // a hasWalkedCache that's a copy of this one\n  // then we're going to call\n  filterEntries(parent: Path, entries: Path[]): Processor {\n    const patterns = this.subwalks.get(parent)\n    // put matches and entry walks into the results processor\n    const results = this.child()\n    for (const e of entries) {\n      for (const pattern of patterns) {\n        const absolute = pattern.isAbsolute()\n        const p = pattern.pattern()\n        const rest = pattern.rest()\n        if (p === GLOBSTAR) {\n          results.testGlobstar(e, pattern, rest, absolute)\n        } else if (p instanceof RegExp) {\n          results.testRegExp(e, p, rest, absolute)\n        } else {\n          results.testString(e, p, rest, absolute)\n        }\n      }\n    }\n    return results\n  }\n\n  testGlobstar(\n    e: Path,\n    pattern: Pattern,\n    rest: Pattern | null,\n    absolute: boolean\n  ) {\n    if (this.dot || !e.name.startsWith('.')) {\n      if (!pattern.hasMore()) {\n        this.matches.add(e, absolute, false)\n      }\n      if (e.canReaddir()) {\n        // if we're in follow mode or it's not a symlink, just keep\n        // testing the same pattern. If there's more after the globstar,\n        // then this symlink consumes the globstar. If not, then we can\n        // follow at most ONE symlink along the way, so we mark it, which\n        // also checks to ensure that it wasn't already marked.\n        if (this.follow || !e.isSymbolicLink()) {\n          this.subwalks.add(e, pattern)\n        } else if (e.isSymbolicLink()) {\n          if (rest && pattern.checkFollowGlobstar()) {\n            this.subwalks.add(e, rest)\n          } else if (pattern.markFollowGlobstar()) {\n            this.subwalks.add(e, pattern)\n          }\n        }\n      }\n    }\n    // if the NEXT thing matches this entry, then also add\n    // the rest.\n    if (rest) {\n      const rp = rest.pattern()\n      if (\n        typeof rp === 'string' &&\n        // dots and empty were handled already\n        rp !== '..' &&\n        rp !== '' &&\n        rp !== '.'\n      ) {\n        this.testString(e, rp, rest.rest(), absolute)\n      } else if (rp === '..') {\n        /* c8 ignore start */\n        const ep = e.parent || e\n        /* c8 ignore stop */\n        this.subwalks.add(ep, rest)\n      } else if (rp instanceof RegExp) {\n        this.testRegExp(e, rp, rest.rest(), absolute)\n      }\n    }\n  }\n\n  testRegExp(\n    e: Path,\n    p: MMRegExp,\n    rest: Pattern | null,\n    absolute: boolean\n  ) {\n    if (!p.test(e.name)) return\n    if (!rest) {\n      this.matches.add(e, absolute, false)\n    } else {\n      this.subwalks.add(e, rest)\n    }\n  }\n\n  testString(e: Path, p: string, rest: Pattern | null, absolute: boolean) {\n    // should never happen?\n    if (!e.isNamed(p)) return\n    if (!rest) {\n      this.matches.add(e, absolute, false)\n    } else {\n      this.subwalks.add(e, rest)\n    }\n  }\n}\n"]}