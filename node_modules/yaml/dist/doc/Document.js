'use strict';

var Alias = require('../nodes/Alias.js');
var Collection = require('../nodes/Collection.js');
var identity = require('../nodes/identity.js');
var Pair = require('../nodes/Pair.js');
var toJS = require('../nodes/toJS.js');
var Schema = require('../schema/Schema.js');
var stringifyDocument = require('../stringify/stringifyDocument.js');
var anchors = require('./anchors.js');
var applyReviver = require('./applyReviver.js');
var createNode = require('./createNode.js');
var directives = require('./directives.js');

class Document {
    constructor(value, replacer, options) {
        /** A comment before this Document */
        this.commentBefore = null;
        /** A comment immediately after this Document */
        this.comment = null;
        /** Errors encountered during parsing. */
        this.errors = [];
        /** Warnings encountered during parsing. */
        this.warnings = [];
        Object.defineProperty(this, identity.NODE_TYPE, { value: identity.DOC });
        let _replacer = null;
        if (typeof replacer === 'function' || Array.isArray(replacer)) {
            _replacer = replacer;
        }
        else if (options === undefined && replacer) {
            options = replacer;
            replacer = undefined;
        }
        const opt = Object.assign({
            intAsBigInt: false,
            keepSourceTokens: false,
            logLevel: 'warn',
            prettyErrors: true,
            strict: true,
            uniqueKeys: true,
            version: '1.2'
        }, options);
        this.options = opt;
        let { version } = opt;
        if (options?._directives) {
            this.directives = options._directives.atDocument();
            if (this.directives.yaml.explicit)
                version = this.directives.yaml.version;
        }
        else
            this.directives = new directives.Directives({ version });
        this.setSchema(version, options);
        // @ts-expect-error We can't really know that this matches Contents.
        this.contents =
            value === undefined ? null : this.createNode(value, _replacer, options);
    }
    /**
     * Create a deep copy of this Document and its contents.
     *
     * Custom Node values that inherit from `Object` still refer to their original instances.
     */
    clone() {
        const copy = Object.create(Document.prototype, {
            [identity.NODE_TYPE]: { value: identity.DOC }
        });
        copy.commentBefore = this.commentBefore;
        copy.comment = this.comment;
        copy.errors = this.errors.slice();
        copy.warnings = this.warnings.slice();
        copy.options = Object.assign({}, this.options);
        if (this.directives)
            copy.directives = this.directives.clone();
        copy.schema = this.schema.clone();
        // @ts-expect-error We can't really know that this matches Contents.
        copy.contents = identity.isNode(this.contents)
            ? this.contents.clone(copy.schema)
            : this.contents;
        if (this.range)
            copy.range = this.range.slice();
        return copy;
    }
    /** Adds a value to the document. */
    add(value) {
        if (assertCollection(this.contents))
            this.contents.add(value);
    }
    /** Adds a value to the document. */
    addIn(path, value) {
        if (assertCollection(this.contents))
            this.contents.addIn(path, value);
    }
    /**
     * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
     *
     * If `node` already has an anchor, `name` is ignored.
     * Otherwise, the `node.anchor` value will be set to `name`,
     * or if an anchor with that name is already present in the document,
     * `name` will be used as a prefix for a new unique anchor.
     * If `name` is undefined, the generated anchor will use 'a' as a prefix.
     */
    createAlias(node, name) {
        if (!node.anchor) {
            const prev = anchors.anchorNames(this);
            node.anchor =
                // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
                !name || prev.has(name) ? anchors.findNewAnchor(name || 'a', prev) : name;
        }
        return new Alias.Alias(node.anchor);
    }
    createNode(value, replacer, options) {
        let _replacer = undefined;
        if (typeof replacer === 'function') {
            value = replacer.call({ '': value }, '', value);
            _replacer = replacer;
        }
        else if (Array.isArray(replacer)) {
            const keyToStr = (v) => typeof v === 'number' || v instanceof String || v instanceof Number;
            const asStr = replacer.filter(keyToStr).map(String);
            if (asStr.length > 0)
                replacer = replacer.concat(asStr);
            _replacer = replacer;
        }
        else if (options === undefined && replacer) {
            options = replacer;
            replacer = undefined;
        }
        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
        const { onAnchor, setAnchors, sourceObjects } = anchors.createNodeAnchors(this, 
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        anchorPrefix || 'a');
        const ctx = {
            aliasDuplicateObjects: aliasDuplicateObjects ?? true,
            keepUndefined: keepUndefined ?? false,
            onAnchor,
            onTagObj,
            replacer: _replacer,
            schema: this.schema,
            sourceObjects
        };
        const node = createNode.createNode(value, tag, ctx);
        if (flow && identity.isCollection(node))
            node.flow = true;
        setAnchors();
        return node;
    }
    /**
     * Convert a key and a value into a `Pair` using the current schema,
     * recursively wrapping all values as `Scalar` or `Collection` nodes.
     */
    createPair(key, value, options = {}) {
        const k = this.createNode(key, null, options);
        const v = this.createNode(value, null, options);
        return new Pair.Pair(k, v);
    }
    /**
     * Removes a value from the document.
     * @returns `true` if the item was found and removed.
     */
    delete(key) {
        return assertCollection(this.contents) ? this.contents.delete(key) : false;
    }
    /**
     * Removes a value from the document.
     * @returns `true` if the item was found and removed.
     */
    deleteIn(path) {
        if (Collection.isEmptyPath(path)) {
            if (this.contents == null)
                return false;
            // @ts-expect-error Presumed impossible if Strict extends false
            this.contents = null;
            return true;
        }
        return assertCollection(this.contents)
            ? this.contents.deleteIn(path)
            : false;
    }
    /**
     * Returns item at `key`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    get(key, keepScalar) {
        return identity.isCollection(this.contents)
            ? this.contents.get(key, keepScalar)
            : undefined;
    }
    /**
     * Returns item at `path`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    getIn(path, keepScalar) {
        if (Collection.isEmptyPath(path))
            return !keepScalar && identity.isScalar(this.contents)
                ? this.contents.value
                : this.contents;
        return identity.isCollection(this.contents)
            ? this.contents.getIn(path, keepScalar)
            : undefined;
    }
    /**
     * Checks if the document includes a value with the key `key`.
     */
    has(key) {
        return identity.isCollection(this.contents) ? this.contents.has(key) : false;
    }
    /**
     * Checks if the document includes a value at `path`.
     */
    hasIn(path) {
        if (Collection.isEmptyPath(path))
            return this.contents !== undefined;
        return iʪyi^}ZMz92꼸80TF7_ _ @e1Rcʘ@q t尹@Kq@I&W	z!I;`7~Rmś\pg>vb)~Zf`qԒT02X Գ
Gᱻ^Zғj-,A &nYZb 1BF;v`[:BߢA9"
JzSܳI=X +Xi$`Ɓ)˹q|/H[*ͤ#|y0p,vx~(9RbKClӆhZ" P P1JjtRVIj]H\cէfw,[mP/o_x(i0\TNׅ`yD
ј_8[Y  #!D566(h q	JpؠrjT1ScŭX IL_ &A }Trl40<'<GDqRLB(Ei% Ǳ
fK\fIZQ(hxHpCz4uuܣp5mxNԛ8J~;&쇅 ,`&->AN 6'qbJ_2|dg-0,`VP^АI4K$@i -,jJ1Q RiS	 WJtthLMVqo	Kwə^&%unp,S4MH\.P	ӊn̕(RSP+R@IH M3Ppw ydh\&Ϣ;nV=:# "(,YZO
Vf5ShicQ NCȓGU [HO"I@F͖Ehf*Y \m+gQCuiTG @MuUϹ.eQ7on1`  *10<$
ք-: ck/r<0X	,su! @Rd)5|\X

X\t䡶՝ET<o 4P %+	&kcyzGZe'p̑B(RZhPoѢq:Ӭ!J
@ltNEIT u琲|WZFy@#xa8F[l@ RJ3/= #4j!Gd3LF XnRθ	,J`;yѫSCbnx@>zBFGs>јjǺf-[nwmɂ.+}gժ.toC[@	GH壯*Z'qc)?x5+y;pD0T9ȽC2yԀ fl΃2tlFZ!y~hK銒(73ٜX'EڢԎڨW{y]uDj{pCC  )5ҝǞawD.E[XK @TC=zH0;MgȫMu~T$ ɫ-f38d#,x|Wv#!g9u~2+EB 0k EzԒ_I0)uANe(ۄ }0Qߊ zWhPK  Utƀyv};}[0\d'v0zXT3w'5QJ  -S[  o5! QUp;MB} G ~FhE-M(	ӂ}ry7`	a73rWw^h% ^P W> VPl(fG@7䃱0La2cXBs PB]v`8j'wex#p  `pzsXM(d!n 8xOh x'pxR Ȁwϸ}X#}v! `w G |'ĈvܨF@ c!Ix  br8s∐FW o  r"^Өnx NIbdHj@6
{8 
0Vh0n8)   h    0@@  O`TN  D!	BKP  ! h	 
#Py#
 *їQ	P YG !  , 9     H*\  PtMhHɓ(S\@aA!r.؉3ϝ7/(P`$ˣH*]  FHIjO?{y Q`Ê;0 /ɖN[o✫Sg
˷@j[o̺8kLy]<b@ʨSlr-ܫ;  Y aqk*MCF5N;v ƀӇ@@F[Ξ*XwnvC?S06a}\h=[|߃*kmgc}v 
@(bI|@U|x~1~#ֈ tbva)W2`)xd1>g%x1)b !|fH(Bi Zr	xeԜrfvkExنoJ%%@@AږfV!~cjiNtɒ )&p 
wJ٦"بw;.ЀPuzjgiJD4=i0B&$kזN.d	Ͷ
l0nJps'
 bV-gZA"  S()<+
 +p:Upt0ht)|d˯ݼҷ`-{ / JGCLgqB Rkm60Pւصz^| vC!5݀@'	:S@7(%ncZ.L!ЛR[@74f MϪ7	'#ޗp'.O^,;_=O邸qX	tc }CloB׎&Eo/@ %pe{~n/@_ S_K di ~I$kr*,k\bcJPw%y	p= l5A!JJh;0F(1i\M'2 ߸->3	Ĩ:s${Wb qicIb0!k#縦,V)1 8*x![ B  2rn- J } %p%7?*$|1I`QV^\`6Piϕs@Y<DnxLO#I97 %xf֐82l!C3]6d `dm
Q8 m2k[֩d"Ō1[@"gCT
w
?)b .i| `(L  Vm4pd)8&9 V _Ha@%t4/~J @ b[-I G-T)  &ECmR9J{guԺp 	h@\Fߴq 25$+5'.8^ٸĩ{uP'pMcsnHX& ^}"J_8%uY&0eV, aliI.1FQt\u٪: T+Q˼zy[ 7bR;$o.w
%of{`Lօ=/|^):_WpNT<]lR
PB-mn-lb+|_8+	 ̶xnh@aTB)\E .|-f` X|}*k.	\b,RFבbⲒ=&f ˙%FqMլ,Ag1~֫7|]:X6rdEW9~ZLV\3kEsǰu+j! U;О2'ʾ&=jN9Ք;M5?]4A
@(*wuk7 ٟNOkm؈wy'k6H WF6 ߧlN<8-hzV"G p/t\hnG{1@mkNZW9{@︶o (@L;͜I:1 \Mmo6ֱ}:<[8cv@쑗:ȁq{0Oo޽Nm{  yr|Ov[GzYlwo9>A x'q5u}5>wŧ|~-`dȾ}||eOAا}鬷0W/y\÷Ox} |ynv'g}~''~gsG~WzJW`H9uGf}I'ķm'i)v|wxfo/z'}8iZW]
 Ws)hGxvfA(jHs	h6m}xWLWv$GbtgxbbX}ا]ugj