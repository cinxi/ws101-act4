à´±àµâ€Œà´µàµ¼à´•àµà´•àµ à´µà´¿à´¶à´¦à´¾à´‚à´¶à´™àµà´™àµ¾à´•à´£à´•àµà´·àµ» à´®à´¾à´±àµà´± à´µà´¿à´µà´°à´™àµà´™àµ¾à´¤àµà´°àµ‚à´ªàµà´Ÿàµà´Ÿàµ à´²àµˆàµ» à´šà´¾àµ¼à´Ÿàµà´Ÿàµà´¡àµ—àµºà´¸àµà´Ÿàµà´°àµ€à´‚ à´¤àµà´°àµ‚à´ªàµà´Ÿàµà´Ÿàµ à´…à´—àµà´°à´¿à´—àµ‡à´·àµ»à´¡àµ—àµºà´¸àµà´Ÿàµà´°àµ€à´‚ à´¤àµà´°àµ‚à´ªàµà´Ÿàµà´Ÿàµ (mbps)à´«à´²à´ªàµà´°à´¦à´®à´¾à´¯ à´•à´£à´•àµà´·àµ» à´¤à´°à´‚à´•à´£à´•àµà´·à´¨àµâ€ à´¨à´¾à´®à´‚à´…à´µà´¸à´¾à´¨à´¤àµà´¤àµ† à´«à´²à´ªàµà´°à´¦à´®à´¾à´¯ à´•à´£à´•àµà´·àµ»à´¡à´¾à´±àµà´±à´¾ à´¤à´°à´‚à´®àµ‚à´²àµà´¯à´™àµà´™àµ¾à´®à´§àµà´¯à´‚à´®àµ€à´¡à´¿à´¯àµ»20 à´¶à´¤à´®à´¾à´¨à´‚80 à´¶à´¤à´®à´¾à´¨à´‚à´¸à´¾à´§à´¾à´°à´£ à´µàµà´¯à´¤à´¿à´šà´²à´¨à´‚à´…à´µà´¸à´¾à´¨à´‚ à´¨à´¿à´°àµ€à´•àµà´·à´¿à´šàµà´šà´¤àµ[à´•à´£à´•àµà´·àµ» à´®à´¾à´±àµà´±à´‚]à´¸à´¿à´—àµà´¨à´²àµâ€ à´¶à´•àµà´¤à´¿à´µàµ†à´¬àµ à´ªàµ‡à´œàµ à´¤àµà´°àµ‚à´ªàµà´Ÿàµà´Ÿàµ à´µà´¿à´¶à´¦à´¾à´‚à´¶à´™àµà´™àµ¾à´ªàµ‡à´œàµ à´¨à´¾à´®à´‚à´šà´¾àµ¼à´Ÿàµà´Ÿàµ à´µà´°à´¯àµà´•àµà´•àµà´•à´¶àµà´ªà´¾àµ¼à´¶à´¿à´¤ à´ªàµà´°à´µàµ¼à´¤àµà´¤à´¨à´™àµà´™àµ¾à´¸àµà´°à´•àµà´·à´¬àµà´°àµ—à´¸àµ¼ à´Žà´¸àµ»à´·àµà´¯àµ½à´¸à´¿à´²àµ‡à´•àµà´•àµ à´¸àµà´µà´¾à´—à´¤à´‚!à´¨à´¿à´™àµà´™à´³àµà´Ÿàµ† à´¬àµà´°àµ—à´¸à´±à´¿à´¨àµà´±àµ† à´ªàµà´°à´•à´Ÿà´¨à´¤àµà´¤àµ†à´¯àµà´‚ à´¸àµà´°à´•àµà´·à´¯àµ†à´¯àµà´‚ à´•àµà´±à´¿à´šàµà´šàµ à´‡à´µà´¿à´Ÿàµ† à´¦àµà´°àµà´¤ à´•à´¾à´´àµâ€Œà´šà´¯à´¿àµ½ à´®à´¨à´¸àµà´¸à´¿à´²à´¾à´•àµà´•àµà´•.à´¨à´¿à´™àµà´™à´³àµà´Ÿàµ† à´¬àµà´°àµ—à´¸à´±à´¿à´¨àµà´±àµ† à´ªàµà´°à´•à´Ÿà´¨à´µàµà´‚ à´¸àµà´°à´•àµà´·à´¯àµà´‚ à´®àµ†à´šàµà´šà´ªàµà´ªàµ†à´Ÿàµà´¤àµà´¤à´¾àµ» à´¨à´¿à´™àµà´™àµ¾ à´¸àµà´µàµ€à´•à´°à´¿à´•àµà´•àµ‡à´£àµà´Ÿ à´šà´¿à´² à´¨à´Ÿà´ªà´Ÿà´¿à´•à´³àµà´‚ à´žà´™àµà´™àµ¾ à´¶àµà´ªà´¾àµ¼à´¶ à´šàµ†à´¯àµà´¯àµà´‚.à´¬àµà´°àµ—à´¸àµ¼ à´Žà´¸àµ»à´·àµà´¯àµ½à´¸àµ à´Žà´¨àµà´¨à´¤à´¿à´¨àµ† à´•àµà´±à´¿à´šàµà´šàµ à´•àµ‚à´Ÿàµà´¤à´²à´±à´¿à´¯àµà´•à´¬àµà´°àµ—à´¸àµ¼ à´Žà´¸àµ»à´·àµà´¯àµ½à´¸àµ à´¸àµà´µà´¾à´—à´¤à´‚ à´šàµ†à´¯àµà´¯àµà´¨àµà´¨ à´‰à´³àµà´³à´Ÿà´•àµà´•à´‚ à´¡à´¿à´¸àµâ€à´®à´¿à´¸àµ à´šàµ†à´¯àµà´¯àµà´•$1 à´Žà´¨àµà´¨à´¤à´¿à´¨à´¾à´¯àµà´³àµà´³ à´•àµ‚à´Ÿàµà´¤àµ½ à´à´šàµà´›à´¿à´•à´™àµà´™à´³àµâ€à´‰à´ªà´•à´°à´£à´¬à´¾à´±à´¿àµ½ à´¬àµà´°àµ—à´¸àµ¼ à´Žà´¸àµ»à´·àµà´¯àµ½à´¸àµ à´¬à´Ÿàµà´Ÿàµº à´•à´¾à´£à´¿à´•àµà´•àµà´•à´‰à´ªà´•à´°à´£à´¬à´¾à´±à´¿àµ½ à´¨à´¿à´¨àµà´¨àµ à´¬àµà´°àµ—à´¸àµ¼ à´Žà´¸àµ»à´·àµà´¯àµ½à´¸àµ à´¬à´Ÿàµà´Ÿàµº à´®à´±à´¯àµà´•àµà´•àµà´•à´¬àµà´°àµ—à´¸àµ¼ à´Žà´¸àµ»à´·àµà´¯àµ½à´¸àµ à´¸à´œàµà´œàµ€à´•à´°à´£à´™àµà´™àµ¾ à´®à´¾à´¨àµ‡à´œàµ à´šàµ†à´¯àµà´¯àµà´•à´ªàµà´°à´•à´Ÿà´¨ à´¸à´œàµà´œàµ€à´•à´°à´£à´™àµà´™àµ¾ à´®à´¨àµ‡à´œàµ à´šàµ†à´¯àµà´¯àµà´•à´¸àµà´°à´•àµà´·à´¾ à´¸à´œàµà´œàµ€à´•à´°à´£à´™àµà´™àµ¾ à´®à´¾à´¨àµ‡à´œàµ à´šàµ†à´¯àµà´¯àµà´•à´ªàµà´°à´•à´Ÿà´¨à´¤àµà´¤àµ†à´•àµà´•àµà´±à´¿à´šàµà´šàµ à´•àµ‚à´Ÿàµà´¤à´²à´±à´¿à´¯àµà´•à´¸àµà´°à´•àµà´·à´¯àµ†à´•àµà´•àµà´±à´¿à´šàµà´šàµ à´•àµ‚à´Ÿàµà´¤à´²à´±à´¿à´¯àµà´•à´¨à´¿à´™àµà´™à´³àµà´Ÿàµ† à´šà´¿à´² à´ªà´¶àµà´šà´¾à´¤àµà´¤à´² à´Ÿà´¾à´¬àµà´•à´³àµà´Ÿàµ† $1 à´‰à´ªà´¯àµ‹à´—à´‚ à´•àµ‚à´Ÿàµà´¤à´²à´¾à´£àµ. à´¨àµ‹à´•àµà´•à´¿à´¯àµ†à´Ÿàµà´•àµà´•àµà´• â€¦ à´’à´¨àµà´¨àµà´•à´¿àµ½ à´¸àµâ€Œà´²àµ€à´ªàµà´ªàµ à´†à´•àµà´•àµà´• à´…à´²àµà´²àµ†à´™àµà´•à´¿àµ½ à´šàµà´µà´Ÿàµ†à´¯àµà´³àµà´³ à´šà´¿à´² à´Ÿà´¾à´¬àµà´•àµ¾ à´…à´²àµà´²àµ†à´™àµà´•à´¿àµ½ à´Žà´²àµà´²à´¾ à´Ÿà´¾à´¬àµà´•à´³àµà´‚ à´…à´Ÿà´¯àµà´•àµà´•àµà´•.à´®àµ†à´®àµà´®à´±à´¿, CPUà´ªàµà´°à´•à´Ÿà´¨ à´ªàµà´°à´¶àµà´¨à´‚ à´ªà´°à´¿à´¹à´°à´¿à´šàµà´šàµà´¨à´¿à´™àµà´™à´³àµà´Ÿàµ† à´ªà´¶àµà´šà´¾à´¤àµà´¤à´² à´Ÿà´¾à´¬àµà´•à´³àµà´Ÿàµ† à´®àµ†à´®àµà´®à´±à´¿à´¯àµà´‚ CPU à´‰à´ªà´¯àµ‹à´—à´µàµà´‚ $1 à´†à´£àµ!à´‡à´ªàµà´ªàµ‹àµ¾ à´¤à´¾à´´àµà´¨àµà´¨àµà´ˆ à´Ÿà´¾à´¬àµà´•àµ¾ à´…à´Ÿà´¯àµà´•àµà´•àµà´•à´ˆ à´Ÿà´¾à´¬àµà´•àµ¾ à´¸àµâ€Œà´²àµ€à´ªàµà´ªàµ à´†à´•àµà´•àµà´•à´Ÿà´¾à´¬àµà´•àµ¾ à´…à´Ÿà´šàµà´šàµ.à´¸àµâ€Œà´²àµ€à´ªàµà´ªàµ à´®àµ‹à´¡à´¿à´²à´¾à´•àµà´•à´¾àµ» à´•à´´à´¿à´¯àµà´¨àµà´¨ à´Ÿà´¾à´¬àµà´•àµ¾ à´¸àµà´²àµ€à´ªàµà´ªàµ à´®àµ‹à´¡à´¿à´²à´¾à´•àµà´•à´¿.à´Ÿà´¾à´¬àµà´•àµ¾ à´…à´Ÿà´šàµà´šàµ. $1à´®à´±àµà´±àµ à´ªàµà´°àµŠà´«àµˆà´²àµà´•à´³à´¿àµ½ à´‡à´ªàµà´ªàµ‹à´´àµà´‚ à´…àde.nodes, functions)
    vNode.type = 'word'
    vNode.value = functions[vNode.value](node, ...args)
  }

  return vNode
}

function resolveFunctions(node, input, functions) {
  let hasAnyFn = Object.keys(functions).some((fn) => input.includes(`${fn}(`))
  if (!hasAnyFn) return input

  return parseValue(input)
    .walk((vNode) => {
      resolveVNode(node, vNode, functions)
    })
    .toString()
}

let nodeTypePropertyMap = {
  atrule: 'params',
  decl: 'value',
}

/**
 * @param {string} path
 * @returns {Iterable<[path: string, alpha: string|undefined]>}
 */
function* toPaths(path) {
  // Strip quotes from beginning and end of string
  // This allows the alpha value to be present inside of quotes
  path = path.replace(/^['"]+|['"]+$/g, '')

  let matches = path.match(/^([^\s]+)(?![^\[]*\])(?:\s*\/\s*([^\/\s]+))$/)
  let alpha = undefined

  yield [path, undefined]

  if (matches) {
    path = matches[1]
    alpha = matches[2]

    yield [path, alpha]
  }
}

/**
 *
 * @param {any} config
 * @param {string} path
 * @param {any} defaultValue
 */
function resolvePath(config, path, defaultValue) {
  const results = Array.from(toPaths(path)).map(([path, alpha]) => {
    return Object.assign(validatePath(config, path, defaultValue, { opacityValue: alpha }), {
      resolvedPath: path,
      alpha,
    })
  })

  return results.find((result) => result.isValid) ?? results[0]
}

export default function (context) {
  let config = context.tailwindConfig

  let functions = {
    theme: (node, path, ...defaultValue) => {
      let { isValid, value, error, alpha } = resolvePath(
        config,
        path,
        defaultValue.length ? defaultValue : undefined
      )

      if (!isValid) {
        let parentNode = node.parent
        let candidate = parentNode?.raws.tailwind?.candidate

        if (parentNode && candidate !== undefined) {
          // Remove this utility from any caches
          context.markInvalidUtilityNode(parentNode)

          // Remove the CSS node from the markup
          parentNode.remove()

          // Show a warning
          log.warn('invalid-theme-key-in-class', [
            `The utility \`${candidate}\` contains an invalid theme value and was not generated.`,
          ])

          return
        }

        throw node.error(error)
      }

      let maybeColor = parseColorFormat(value)
      let isColorFunction = maybeColor !== undefined && typeof maybeColor === 'function'

      if (alpha !== undefined || isColorFunction) {
        if (alpha === undefined) {
          alpha = 1.0
        }

        value = withAlphaValue(maybeColor, alpha, maybeColor)
      }

      return value
    },
    screen: (node, screen) => {
      screen = screen.replace(/^['"]+/g, '').replace(/['"]+$/g, '')
      let screens = normalizeScreens(config.theme.screens)
      let screenDefinition = screens.find(({ name }) => name === screen)

      if (!screenDefinition) {
        throw node.error(`The '${screen}' screen does not exist in your theme.`)
      }

      return buildMediaQuery(screenDefinition)
    },
  }
  return (root) => {
    root.walk((node) => {
      let property = nodeTypePropertyMap[node.type]

      if (property === undefined) {
        return
      }

      node[property] = resolveFunctions(node, node[property], functions)
    })
  }
}
