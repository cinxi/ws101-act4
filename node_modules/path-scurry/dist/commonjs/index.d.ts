/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
import { LRUCache } from 'lru-cache';
import { posix, win32 } from 'path';
import type { Dirent, Stats } from 'fs';
import { Minipass } from 'minipass';
/**
 * An object that will be used to override the default `fs`
 * methods.  Any methods that are not overridden will use Node's
 * built-in implementations.
 *
 * - lstatSync
 * - readdir (callback `withFileTypes` Dirent variant, used for
 *   readdirCB and most walks)
 * - readdirSync
 * - readlinkSync
 * - realpathSync
 * - promises: Object containing the following async methods:
 *   - lstat
 *   - readdir (Dirent variant only)
 *   - readlink
 *   - realpath
 */
export interface FSOption {
    lstatSync?: (path: string) => Stats;
    readdir?: (path: string, options: {
        withFileTypes: true;
    }, cb: (er: NodeJS.ErrnoException | null, entries?: Dirent[]) => any) => void;
    readdirSync?: (path: string, options: {
        withFileTypes: true;
    }) => Dirent[];
    readlinkSync?: (path: string) => string;
    realpathSync?: (path: string) => string;
    promises?: {
        lstat?: (path: string) => Promise<Stats>;
        readdir?: (path: string, options: {
            withFileTypes: true;
        }) => Promise<Dirent[]>;
        readlink?: (path: string) => Promise<string>;
        realpath?: (path: string) => Promise<string>;
        [k: string]: any;
    };
    [k: string]: any;
}
interface FSValue {
    lstatSync: (path: string) => Stats;
    readdir: (path: string, options: {
        withFileTypes: true;
    }, cb: (er: NodeJS.ErrnoException | null, entries?: Dirent[]) => any) => void;
    readdirSync: (path: string, options: {
        withFileTypes: true;
    }) => Dirent[];
    readlinkSync: (path: string) => string;
    realpathSync: (path: string) => string;
    promises: {
        lstat: (path: string) => Promise<Stats>;
        readdir: (path: string, options: {
            withFileTypes: true;
        }) => Promise<Dirent[]>;
        readlink: (path: string) => Promise<string>;
        realpath: (path: string) => Promise<string>;
        [k: string]: any;
    };
    [k: string]: any;
}
export type Type = 'Unknown' | 'FIFO' | 'CharacterDevice' | 'Directory' | 'BlockDevice' | 'File' | 'SymbolicLink' | 'Socket';
/**
 * Options that may be provided to the Path constructor
 */
export interface PathOpts {
    fullpath?: string;
    relative?: string;
    relativePosix?: string;
    parent?: PathBase;
    /**
     * See {@link FSOption}
     */
    fs?: FSOption;
}
/**
 * An LRUCache for storing resolved path strings or Path objects.
 * @internal
 */
export declare class ResolveCache extends LRUCache<string, string> {
    constructor();
}
/**
 * an LRUCache for storing child entries.
 * @internal
 */
export declare class ChildrenCache extends LRUCache<PathBase, Children> {
    constructor(maxSize?: number);
}
/**
 * Array of Path objects, plus a marker indicating the first provisional entry
 *
 * @internal
 */
export type Children = PathBase[] & {
    provisional: number;
};
declare const setAsCwd: unique symbol;
/**
 * Path objects are sort of like a super-powered
 * {@link https://nodejs.org/docs/latest/api/fs.html#class-fsdirent fs.Dirent}
 *
 * Each one represents a single filesystem entry on disk, which may or may not
 * exist. It includes methods for reading various types of information via
 * lstat, readlink, and readdir, and caches all information to the greatest
 * degree possible.
 *
 * Note that fs operations that would normally throw will instead return an
 * "empty" value. This is in order to prevent excessive overhead from error
 * stack traces.
 */
export declare abstract class PathBase implements Dirent {
    #private;
    /**
     * the basename of this path
     *
     * **Important**: *always* test the path name against any test string
     * usingthe {@link isNamed} method, and not by directly comparing this
     * string. Otherwise, unicode path strings that the system sees as identical
     * will not be properly treated as the same path, leading to incorrect
     * behavior and possible security issues.
     */
    name: string;
    /**
     * the Path entry corresponding to the path root.
     *
     * @internal
     */
    root: PathBase;
    /**
     * All roots found within the current PathScurry family
     *
     * @internal
     */
    roots: {
        [k: string]: PathBase;
    };
    /**
     * a reference to the parent path, or undefined in the case of root entries
     *
     * @internal
     */
    parent?: PathBase;
    /**
     * boolean indicating whether paths are compared case-insensitively
     * @internal
     */
    nocase: boolean;
    /**
     * the string or regexp used to split paths. On posix, it is `'/'`, and on
     * windows it is a RegExp matching either `'/'` or `'\\'`
     */
    abstract splitSep: string | RegExp;
    /**
     * The path separator string to use when joining paths
     */
    abstract sep: string;
    get dev(): number | undefined;
    get mode(): number | undefined;
    get nlink(): number | undefined;
    get uid(): number | undefined;
    get gid(): number | undefined;
    get rdev(): number | undefined;
    get blksize(): number | undefined;
    get ino(): number | undefined;
    get size(): number | undefined;
    get blocks(): number | undefined;
    get atimeMs(): number | undefined;
    get mtimeMs(): number | undefined;
    get ctimeMs(): number | undefined;
    get birthtimeMs(): number | undefined;
    get atime(): Date | undefined;
    get mtime(): Date | undefined;
    get ctime(): Date | undefined;
    get birthtime(): Date | undefined;
    /**
     * This property is for compatibility with the Dirent class as of
     * Node v20, where Dirent['path'] refers to the path of the directory
     * that was passed to readdir.  So, somewhat counterintuitively, this
     * property refers to the *parent* path, not the path object itself.
     * For root entries, it's the path to the entry itself.
     */
    get path(): string;
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name: string, type: number | undefined, root: PathBase | undefined, roots: {
        [k: string]: PathBase;
    }, nocase: boolean, children: ChildrenCache, opts: PathOpts);
    /**
     * Returns the depth of the Path object from its root.
     *
     * For example, a path at `/foo/bar` would have a depth of 2.
     */
    depth(): number;
    /**
     * @internal
     */
    abstract getRootString(path: string): string;
    /**
     * @internal
     */
    abstract getRoot(rootPath: string): PathBase;
    /**
     * @internal
     */
    abstract newChild(name: string, type?: number, opts?: PathOpts): PathBase;
    /**
     * @internal
     */
    childrenCache(): ChildrenCache;
    /**
     * Get the Path object referenced by the string path, resolved from this Path
     */
    resolve(path?: string): PathBase;
    /**
     * Returns the cached children Path objects, if still available.  If they
     * have fallen out of the cache, then returns an empty array, and resets the
     * READDIR_CALLED bit, so that future calls to readdir() will require an fs
     * lookup.
     *
     * @internal
     */
    children(): Children;
    /**
     * Resolves a path portion and returns or creates the child Path.
     *
     * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is
     * `'..'`.
     *
     * This should not be called directly.  If `pathPart` contains any path
     * separators, it will lead to unsafe undefined behavior.
     *
     * Use `Path.resolve()` instead.
     *
     * @internal
     */
    child(pathPart: string, opts?: PathOpts): PathBase;
    /**
     * The relative path from the cwd. If it does not share an ancestor with
     * the cwd, then this ends up being equivalent to the fullpath()
     */
    relative(): string;
    /**
     * The relative path from the cwd, using / as the path separator.
     * If it does not share an ancestor with
     * the cwd, then this ends up being equivalent to the fullpathPosix()
     * On posix systems, this is identical to relative().
     */
    relativePosix(): string;
    /**
     * The fully resolved path string for this Path entry
     */
    fullpath(): string;
    /**
     * On platforms other than windows, this is identical to fullpath.
     *
     * On windows, this is overridden to return the forward-slash form of the
     * full UNC path.
     */
    fullpathPosix(): string;
    /**
     * Is the Path of an unknown type?
     *
     * Note that we might know *something* about it if there has been a previous
     * filesystem operation, for example that it does not exist, or is not a
     * link, or whether it has child entries.
     */
    isUnknown(): boolean;
    isType(type: Type): boolean;
    getType(): Type;
    /**
     * Is the Path a regular file?
     */
    isFile(): boolean;
    /**
     * Is the Path a directory?
     */
    isDirectory(): boolean;
    /**
     * Is the path a character device?
     */
    isCharacterDevice(): boolean;
    /**
     * Is the path a block device?
     */
    isBlockDevice(): boolean;
    /**
     * Is the path a FIFO pipe?
     */
    isFIFO(): boolean;
    /**
     * Is the path a socket?
     */
    isSocket(): boolean;
    /**
     * Is the path a symbolic link?
     */
    isSymbolicLink(): boolean;
    /**
     * Return the entry if it has been subject of a successful lstat, or
     * undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* simply
     * mean that we haven't called lstat on it.
     */
    lstatCached(): PathBase | undefined;
    /**
     * Return the cached link target if the entry has been the subject of a
     * successful readlink, or undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * readlink() has been called at some point.
     */
    readlinkCached(): PathBase | undefined;
    /**
     * Returns the cached realpath target if the entry has been the subject
     * of a successful realpath, or undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * realpath() has been called at some point.
     */
    realpathCached(): PathBase | undefined;
    /**
     * Returns the cached child Path entries array if the entry has been the
     * subject of a successful readdir(), or [] otherwise.
     *
     * Does not read the filesystem, so an empty array *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * readdir() has been called recently enough to still be valid.
     */
    readdirCached(): PathBase[];
    /**
     * Return true if it's worth trying to readlink.  Ie, we don't (yet) have
     * any indication that readlink will definitely fail.
     *
     * Returns false if the path is known to not be a symlink, if a previous
     * readlink failed, or if the entry does not exist.
     */
    canReadlink(): boolean;
    /**
     * Return true if readdir has previously been successfully called on this
     * path, indicating that cachedReaddir() is likely valid.
     */
    calledReaddir(): boolean;
    /**
     * Returns true if the path is known to not exist. That is, a previous lstat
     * or readdir failed to verify its existence when that would have been
     * expected, or a parent entry was marked either enoent or enotdir.
     */
    isENOENT(): boolean;
    /**
     * Return true if the path is a match for the given path name.  This handles
     * case sensitivity and unicode normalization.
     *
     * Note: even on case-sensitive systems, it is **not** safe to test the
     * equality of the `.name` property to determine whether a given pathname
     * matches, due to unicode normalization mismatches.
     *
     * Always use this method instead of testing the `path.name` property
     * directly.
     */
    isNamed(n: string): boolean;
    /**
     * Return the Path object corresponding to the target of a symbolic link.
     *
     * If the Path is not a symbolic link, or if the readlink call fails for any
     * reason, `undefined` is returned.
     *
     * Result is cached, and thus may be outdated if the filesystem is mutated.
     */
    readlink(): Promise<PathBase | undefined>;
    /**
     * Synchronous {@link PathBase.readlink}
     */
    readlinkSync(): PathBase | undefined;
    /**
     * Call lstat() on this Path, and update all known information that can be
     * determined.
     *
     * Note that unlike `fs.lstat()`, the returned value does not contain some
     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
     * information is required, you will need to call `fs.lstat` yourself.
     *
     * If the Path refers to a nonexistent file, or if the lstat call fails for
     * any reason, `undefined` is returned.  Otherwise the updated Path object is
     * returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    lstat(): Promise<PathBase | undefined>;
    /**
     * synchronous {@link PathBase.lstat}
     */
    lstatSync(): PathBase | undefined;
    /**
     * Standard node-style callback interface to get list of directory entries.
     *
     * If the Path cannot or does not contain any children, then an empty array
     * is returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     *
     * @param cb The callback called with (er, entries).  Note that the `er`
     * param is somewhat extraneous, as all readdir() errors are handled and
     * simply result in an empty set of entries being returned.
     * @param allowZalgo Boolean indicating that immediately known results should
     * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release
     * zalgo at your peril, the dark pony lord is devious and unforgiving.
     */
    readdirCB(cb: (er: NodeJS.ErrnoException | null, entries: PathBase[]) => any, allowZalgo?: boolean): void;
    /**
     * Return an array of known child entries.
     *
     * If the Path cannot or does not contain any children, then an empty array
     * is returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    readdir(): Promise<PathBase[]>;
    /**
     * synchronous {@link PathBase.readdir}
     */
    readdirSync(): PathBase[];
    canReaddir(): boolean;
    shouldWalk(dirs: Set<PathBase | undefined>, walkFilter?: (e: PathBase) => boolean): boolean;
    /**
     * Return the Path object corresponding to path as resolved
     * by realpath(3).
     *
     * If the realpath call fails for any reason, `undefined` is returned.
     *
     * Result is cached, and thus may be outdated if the filesystem is mutated.
     * On success, returns a Path object.
     */
    realpath(): Promise<PathBase | undefined>;
    /**
     * Synchronous {@link realpath}
     */
    realpathSync(): PathBase | undefined;
    /**
     * Internal method to mark this Path object as the scurry cwd,
     * called by {@link PathScurry#chdir}
     *
     * @internal
     */
    [setAsCwd](oldCwd: PathBase): void;
}
/**
 * Path class used on win32 systems
 *
 * Uses `'\\'` as the path separator for returned paths, either `'\\'` or `'/'`
 * as the path separator for parsing paths.
 */
export declare class PathWin32 extends PathBase {
    /**
     * Separator for generating path strings.
     */
    sep: '\\';
    /**
     * Separator for parsing path strings.
     */
    splitSep: RegExp;
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name: string, type: number | undefined, root: PathBase | undefined, roots: {
        [k: string]: PathBase;
    }, nocase: boolean, children: ChildrenCache, opts: PathOpts);
    /**
     * @internal
     */
    newChild(name: string, type?: number, opts?: PathOpts): PathWin32;
    /**
     * @internal
     */
    getRootString(path: string): string;
    /**
     * @internal
     */
    getRoot(rootPath: string): PathBase;
    /**
     * @internal
     */
    sameRoot(rootPath: string, compare?: string): boolean;
}
/**
 * Path class used on all posix systems.
 *
 * Uses `'/'` as the path separator.
 */
export declare class PathPosix extends PathBase {
    /**
     * separator for parsing path strings
     */
    splitSep: '/';
    /**
     * separator for generating path strings
     */
    sep: '/';
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name: string, type: number | undefined, root: PathBase | undefined, roots: {
        [k: string]: PathBase;
    }, nocase: boolean, children: ChildrenCache, opts: PathOpts);
    /**
     * @internal
     */
    getRootString(path: string): string;
    /**
     * @internal
     */
    getRoot(_rootPath: string): PathBase;
    /**
     * @internal
     */
    newChild(name: string, type?: number, opts?: PathOpts): PathPosix;
}
/**
 * Options that may be provided to the PathScurry constructor
 */
export interface PathScurryOpts {
    /**
     * perform case-insensitive path matching. Default based on platform
     * subclass.
     */
    nocase?: boolean;
    /**
     * Number of Path entries to keep in the cache of Path child references.
     *
     * Setting this higher than 65536 will dramatically increase the data
     * consumption and construction time overhead of each PathScurry.
     *
     * Setting this value to 256 or lower will significantly reduce the data
     * consumption and construction time overhead, but may also reduce resolve()
     * and readdir() performance on large filesystems.
     *
     * Default `16384`.
     */
    childrenCacheSize?: number;
    /**
     * An object that overrides the built-in functions from the fs and
     * fs/promises modules.
     *
     * See {@link FSOption}
     */
    fs?: FSOption;
}
/**
 * The base class for all PathScurry classes, providing the interface for path
 * resolution and filesystem operations.
 *
 * Typically, you should *not* instantiate this class directly, but rather one
 * of the platform-specific classes, or the exported {@link PathScurry} which
 * defaults to the current platform.
 */
export declare abstract class PathScurryBase {
    #private;
    /**
     * The root Path entry for the current working directory of this Scurry
     */
    root: PathBase;
    /**
     * The string path for the root of this Scurry's current working directory
     */
    rootPath: string;
    /**
     * A collection of all roots encountered, referenced by rootPath
     */
    roots: {
        [k: string]: PathBase;
    };
    /**
     * The Path entry corresponding to this PathScurry's current working directory.
     */
    cwd: PathBase;
    /**
     * Perform path comparisons case-insensitively.
     *
     * Defaults true on Darwin and Windows systems, false elsewhere.
     */
    nocase: boolean;
    /**
     * The path separator used for parsing paths
     *
     * `'/'` on Posix systems, either `'/'` or `'\\'` on Windows
     */
    abstract sep: string | RegExp;
    /**
     * This class should not be instantiated directly.
     *
     * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry
     *
     * @internal
     */
    constructor(cwd: string | URL | undefined, pathImpl: typeof win32 | typeof posix, sep: string | RegExp, { nocase, childrenCacheSize, fs, }?: PathScurryOpts);
    /**
     * Get the depth of a provided path, string, or the cwd
     */
    depth(path?: Path | string): number;
    /**
     * Parse the root portion of a path string
     *
     * @internal
     */
    abstract parseRootPath(dir: string): string;
    /**
     * create a new Path to use as root during construction.
     *
     * @internal
     */
    abstract newRoot(fs: FSValue): PathBase;
    /**
     * Determine whether a given path string is absolute
     */
    abstract isAbsolute(p: string): boolean;
    /**
     * Return the cache of child entries.  Exposed so subclasses can create
     * child Path objects in a platform-specific way.
     *
     * @internal
     */
    childrenCache(): ChildrenCache;
    /**
     * Resolve one or more path strings to a resolved string
     *
     * Same interface as require('path').resolve.
     *
     * Much faster than path.resolve() when called multiple times for the same
     * path, because the resolved Path objects are cached.  Much slower
     * otherwise.
     */
    resolve(...paths: string[]): string;
    /**
     * Resolve one or more path strings to a resolved string, returning
     * the posix path.  Identical to .resolve() on posix systems, but on
     * windows will return a forward-slash separated UNC path.
     *
     * Same interface as require('path').resolve.
     *
     * Much faster than path.resolve() when called multiple times for the same
     * path, because the resolved Path objects are cached.  Much slower
     * otherwise.
     */
    resolvePosix(...paths: string[]): string;
    /**
     * find the relative path from the cwd to the supplied path string or entry
     */
    relative(entry?: PathBase | string): string;
    /**
     * find the relative path from the cwd to the supplied path string or
     * entry, using / as the path delimiter, even on Windows.
     */
    relativePosix(entry?: PathBase | string): string;
    /**
     * Return the basename for the provided string or Path object
     */
    basename(entry?: PathBase | string): string;
    /**
     * Return the dirname for the provided string or Path object
     */
    dirname(entry?: PathBase | string): string;
    /**
     * Return an array of known child entries.
     *
     * First argument may be either a string, or a Path object.
     *
     * If the Path cannot or does not contain any children, then an empty array
     * is returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     *
     * Unlike `fs.readdir()`, the `withFileTypes` option defaults to `true`. Set
     * `{ withFileTypes: false }` to return strings.
     */
    readdir(): Promise<PathBase[]>;
    readdir(opts: {
        withFileTypes: true;
    }): Promise<PathBase[]>;
    readdir(opts: {
        withFileTypes: false;
    }): Promise<string[]>;
    readdir(opts: {
        withFileTypes: boolean;
    }): Promise<PathBase[] | string[]>;
    readdir(entry: PathBase | string): Promise<PathBase[]>;
    readdir(entry: PathBase | string, opts: {
        withFileTypes: true;
    }): Promise<PathBase[]>;
    readdir(entry: PathBase | string, opts: {
        withFileTypes: false;
    }): Promise<string[]>;
    readdir(entry: PathBase | string, opts: {
        withFileTypes: boolean;
    }): Promise<PathBase[] | string[]>;
    /**
     * synchronous {@link PathScurryBase.readdir}
     */
    readdirSync(): PathBase[];
    readdirSync(opts: {
        withFileTypes: true;
    }): PathBase[];
    readdirSync(opts: {
        withFileTypes: false;
    }): string[];
    readdirSync(opts: {
        withFileTypes: boolean;
    }): PathBase[] | string[];
    readdirSync(entry: PathBase | string): PathBase[];
    readdirSync(entry: PathBase | string, opts: {
        withFileTypes: true;
    }): PathBase[];
    readdirSync(entry: PathBase | string, opts: {
        withFileTypes: false;
    }): string[];
    readdirSync(entry: PathBase | string, opts: {
        withFileTypes: boolean;
    }): PathBase[] | string[];
    /**
     * Call lstat() on the string or Path object, and update all known
     * information that can be determined.
     *
     * Note that unlike `fs.lstat()`, the returned value does not contain some
     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
     * information is required, you will need to call `fs.lstat` yourself.
     *
     * If the Path refers to a nonexistent file, or if the lstat call fails for
     * any reason, `undefined` is returned.  Otherwise the updated Path object is
     * returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    lstat(entry?: string | PathBase): Promise<PathBase | undefined>;
    /**
     * synchronous {@link PathScurryBase.lstat}
     */
    lstatSync(entry?: string | PathBase): PathBase | undefined;
    /**
     * Return the Path object or string path corresponding to the target of a
     * symbolic link.
     *
     * If the path is not a symbolic link, or if the readlink call fails for any
     * reason, `undefined` is returned.
     *
     * Result is cached, and thus may be outdated if the filesystem is mutated.
     *
     * `{withFileTypes}` option defaults to `false`.
     *
     * On success, returns a Path object if `withFileTypes` option is true,
     * otherwise a string.
     */
    readlink(): Promise<string | undefined>;
    readlink(opt: {
        withFileTypes: false;
    }): Promise<string | undefined>;
    readlink(opt: {
        withFileTypes: true;
    }): Promise<PathBase | undefined>;
    readlink(opt: {
        withFileTypes: boolean;
    }): Promise<PathBase | string | undefined>;
    readlink(entry: string | PathBase, opt?: {
        withFileTypes: false;
    }): Promise<string | undefined>;
    readlink(entry: string | PathBase, opt: {
        withFileTypes: true;
    }): Promise<PathBase | undefined>;
    readlink(entry: string | PathBase, opt: {
        withFileTypes: boolean;
    }): Promise<string | PathBase | undefined>;
    /**
     * synchronous {@link PathScurryBase.readlink}
     */
    readlinkSync(): string | undefined;
    readlinkSync(opt: {
        withFileTypes: false;
    }): string | undefined;
    readlinkSync(opt: {
        withFileTypes: true;
    }): PathBase | undefined;
    readlinkSync(opt: {
        withFileTypes: boolean;
    }): PathBase | string | undefined;
    readlinkSync(entry: string | PathBase, opt?: {
        withFileTypes: false;
    }): string | undefined;
    readlinkSync(entry: string | PathBase, opt: {
        withFileTypes: true;
    }): PathBase | undefined;
    readlinkSync(entry: string | PathBase, opt: {
        withFileTypes: boolean;
    }): string | PathBase | undefined;
    /**
     * Return the Path object or string path corresponding to path as resolved
     * by realpath(3).
     *
     * If the realpath call fails for any reason, `undefined` is returned.
     *
     * Result is cached, and thus may be outdated if the filesystem is mutated.
     *
     * `{withFileTypes}` option defaults to `false`.
     *
     * On success, returns a Path object if `withFileTypes` option is true,
     * otherwise a string.
     */
    realpath(): Promise<string | undefined>;
    realpath(opt: {
        withFileTypes: false;
    }): Promise<string | undefined>;
    realpath(opt: {
        withFileTypes: true;
    }): Promise<PathBase | undefined>;
    realpath(opt: {
        withFileTypes: boolean;
    }): Promise<PathBase | string | undefined>;
    realpath(entry: string | PathBase, opt?: {
        withFileTypes: false;
    }): Promise<string | undefined>;
    realpath(entry: string | PathBase, opt: {
        withFileTypes: true;
    }): Promise<PathBase | undefined>;
    realpath(entry: string | PathBase, opt: {
        withFileTypes: boolean;
    }): Promise<string | PathBase | undefined>;
    realpathSync(): string | undefined;
    realpathSync(opt: {
        withFileTypes: false;
    }): string | undefined;
    realpathSync(opt: {
        withFileTypes: true;
    }): PathBase | undefined;
    realpathSync(opt: {
        withFileTypes: boolean;
    }): PathBase | string | undefined;
    realpathSync(entry: string | PathBase, opt?: {
        withFileTypes: false;
    }): string | undefined;
    realpathSync(entry: string | PathBase, opt: {
        withFileTypes: true;
    }): PathBase | undefined;
    realpathSync(entry: string | PathBase, opt: {
        withFileTypes: boolean;
    }): string | PathBase | undefined;
    /**
     * Async 
î± @fÕ @
 4 R‡–
¿p`P	 B‡	–¿p`P0  $ 4 Ú‡
p	`P‘ ` r   (Ò  i ç     r0‘ Ñ :   (ç î 
x∏ P¿6    
 
4 
2p
( ∞ `µ N  r0
( » (— · PP .`P ^pP F ∂&* 4)  ‡–
¿p`P  ‘  ‚   ( F y  ê2Ã¬ A:ús a>( bpñ  24F  ¡>( `Që6H
Äƒ
\	 \   d 4 2p
( x (Å à 
ƒ¬ `Ü !  ‡p`0P  X Ä   
 
4	 
Rp
( º (≈ € ƒP ,î P6ÌP .˝P $ ∂ 4 R
‡p`P
 T 4 R‡¿p`
(  (9‘  1 æ	  
 d T 4 r‡p
( H (Q f ( 6Q .Q .-Q ¢⁄  4 R	‡p`
( Ñ (ç ¢ ( 6=Q .MQ .]Q é∂ (	 h 44 . ‡	p`  ‘ Ã R  (’  
( 6mQ .}Q .çQ *ò †
º–
∆T  " 42 , 	‡p`  ‘  R  (’ % 
∏Œ
∆T  T 4 R‡p`
( L (ç U êd   d
 4	 Rp
( t (} â ©Q 2,◊ ÄJ B6 4 2p
( § (≠ ¥ y  Ä<  
4 
RpX (    T 4 í‡p`
( Ë (Ò ˛ 
(è  @:(è  @Öb⁄    4 r
‡p`P
 4 2‡–
¿p`P t	 d 4 2‡ 4* ( p  ‘ d 2  (m t 
ò `î (   4 “P
( ê (ô ∞ R .( R4F  P24F  ê¬(4ç  ! h * 0  ‘ ÿ 2  (m · ö ( %
 4 “‡–
¿p`P‘  b   ( , @R .( Ry  †24F  `
]I4ëX  * 4  ‡–
¿p`P  ‘ d í   (m ê ~R .( Rx  †24F  ‡2y  ¿24F  `–ÄΩf
Æ4
u2 # d T 4
 rp‘ ƒ :   (° Õ 	    4  p  ‘  ¢   (˘  ( 2†Á `u<  , d! 4   ‡–pP  ‘ 4 ≤   (= H ‡R .S ïF˛ 
4	 
Rp‘ h *   (µ… q F  d 4
 Rp‘ ê *   (µ… ô R + h 4  ‡
p	`P  ‘ ƒ r   (Õ  
4F  †6/S Z,◊ `äy  ÄædS ‚,◊ Pà Ù>
 $‰6¯$1   t d 4
 r‡
( ( (1 7 ôS ¬  %
 4 “‡–
¿p`P‘ ` b   (i ã øS .ÂS R,◊ @ÜT ™,◊ `⁄y  †ÊVa"
qÆú  ! 4 ≤
‡p`P‘ ¿ R   (… ’ 
4F  `6( t      “p0P‘ ¯ b   (  
4F  Ä6[T Z,◊ @äy  `d $B"nI   d 4 íp‘ D B   (M _ êT 2,◊ @by  `
b B$vÆ    
4 
íp‘ Ñ B   (M ç 
R F$vÆ  d 4 R‡p
( ¥ (Ω “ ≈T .( V’T .ÂT û »  d
 T	 4 Rp'
 d 4 í‡¿pP‘  J   (   
4F  P) %—   , d3 40 * ‡¿pP  ‘ T B  (] í U .( Rñ  †6( Zñ  ‡6( Zÿ' ¡:ñ  A>( }
D®5
NN
Ï  4 “p`P‘ ¿ b   (—» … π  a    d 4 rpX 0    d	 T 4 ‡–¿p   t d T 4 ‡–¿ d T 4 rp
( @ (I m ( 6WU .( VgU .( VwU .áU 
N~$8µ    '
  ‡	–¿p`0P‘ †     (© » ( 2ñ  °>( bñ  !>( `Ù
Z L   4
 2	‡p` 4 R
‡p`P
 4 2‡–
¿p`P
(  (·Â ! e    ! 4  p`P  ‘ H ¢   (Q ^ 
º> @2¸ `
^ Tö8     rp`0
( Ä (â ê 
4F  @& |"  # d T 4 rp‘ ∏ :   (çﬂ ¡ å‰H `   d 4 “p
( ‰ (Ì ˘ ˚W .( Px x  " 4  p`P  ‘   Ç   () ; qW *pñ  ¿6( XbFï\    R	‡¿p`P0 T 4 R‡p`
( x (Å á ∏6 B  (	 d! 4   ‡pP  ‘ ∞     (π „ rV .òV *pñ  °äpñ  ° pñ  °>ÕV .ÛV å (dp
*`  (	 d! 4   ‡pP  ‘      (π ! å (dp
*`≠    (	 d! 4   ‡pP  ‘ X     (π a å (dp
*`ù    (	 d! 4   ‡pP  ‘ ò     (π ° å (dp
*`ç    # Ú	‡¿p`0P‘ ‘ r   (› Ù ( 2pñ  †6( Zpñ  `Ã’: (
 4 Ú‡–
¿p`P‘    z   ()  R  
pñ  `08F( hzpñ  ∞2pñ  `08F( h¶( »Ÿ ~> »|‡™ @!  ‡p`0P  ‘ Ñ  í   (ç  ∞  W .?W *pñ  ‡Çpñ  ‡∫pñ  ‡6( Xí r$ ^å
jH  &	 4  
‡p`P  ‘ ‰  ¢   (Ì  ! qW .( Rpñ  ¿Ä:pñ  >( `%: 
up
L<   d 4 ≤‡pP
( @! (I! U! qW .( PˆU $ 4 Ú
‡p`P‘ |! r   (Ö! ñ! óW .( Rpñ  †ÿ*›  & d 4 Ú‡pP‘ ¿! z   (…! ÷! …W .( PXò⁄   B  
( ! (˘! ˇ! eW º   R0
( " (" (" ÓU .˛U B Ç    2‡	p`P0 4 2p
( T" (]" h" V .<V X >Z  t	 d 4 2‡
( å" (ï" ú" 
$> `ò V$   d 4 rp
( º" ( ≈" ¶'	 T+ 4* & ‡p`  X     t  r	‡¿p`P0
( # (# "# 
»~ `:= `	r•  
 t
 d	 4 2‡¿ r	‡¿p`P0
 4 í‡–
¿p`P 4 Rp`PX (    
4 
“p‘ †# b   (µ… ©# ˆ  
4 
“p‘ ƒ# b   (µ… Õ# »  
4 
“p‘ Ë# b   (µ… Ò# ˙  Rp`0 t d
 T	 4 2‡¿# #t #d #4 #“‡–¿P-
 M ‡	–¿p`0PX P   Rp`0
( l$ (u$ ã$ ( 4pñ  @6( ^7Y v"  T	 4 2‡p`
( ¨$ (µ$ ∆$ 
‡r †6( f( ¡. d 4
 Rp‘ Ë$ *   (Ò$ ˝$ 
‡r @>( ñ`"  
4	 
Rp‘ % *   (Ò$ %% hR0 # d T 4
 rp‘ L% :   (Ò$ U% †Z,  d T	 4 Rp
( x% (Å% ç% 
‡r †>( Nr   d T 4 R‡–¿p
( ∏% (¡% ˛% ( 6öY .( V™Y .( V∫Y .( V Y .( V⁄Y .( VÌY Õñ  d 4 2p
( & (%& ?& 
GY .WY .gY .wY .áY Ç NNNZí
   
( X& ha& ª… ( 08@HPX   )	 t d 4  P  ‘ î& ä   (ù& ™& 
pñ  –2pñ  Ä
å fV`      t 4 ≤P‘ ‘& R   (›& È& ( 2pñ  `^ Ò8 % t 4  P  ‘ ' í   (' 5' ( 2pñ  ‡2pñ  †2pñ  `ÆBD∏    t 4 “P
( X' (a' h' 
pñ  †d B   .	 dD 4C > ‡pP  ‘ î' ‚  (ù' Æ' Q8 .( Rpñ  ∞Eàµ )	 t d 4  P  ‘ ‹' ¢   (Â' 	( ( 2pñ  :pñ  Ä2pñ  ¿û( ¬pñ  ¿ÄfBVflÚ % t 4  P  ‘ 8( í   (' A( 
ÆBDrB % t 4  P  ‘ l( ¢   (u( ê( 
pñ  ∞2pñ  rpñ  :pñ  p
Ä f^JF   4 ÚpX p    d 4 rpX 8    
4 
≤p‘ ‡( Z   (È( ( 
4_ Pv &f   4 Úp‘ ) r   () &) 
pñ  †2pñ  `
Ü 8XJ@    - t d 4  ‡P  ‘ \) ä   (e) ~) 
pñ  ¿2pñ  Äjpñ  Ä2pñ  ¿å pB\B dLNB j@Np     4 Úp‘ ¥) r   () Ω) 
Ü 8f@> (	 d  4  ‡pP  ‘ Ï)     (ı) * ( 2pñ  °>( bpñ  !:pñ  ¿2pñ  ÄàF$
BV
|   # d 4 í‡pP‘ L* B   (U* \* 
 t P‡ ¨¨  $ d& 4% " p  X    7 &‘9 &t8 &d7 &46 &2 ‡P  ‘ ¨* ä  (µ* Ó* 
4_ a:pñ  ¿2pñ  Äöpñ  Å:pñ  pñ  ÅBpñ  y  °"† $lN^Ff@
L.f@L\@©Œ    T 4 Ú‡p`
( 0+ (A⁄ 9+ ¯ »N '
  ‡	–¿p`0P‘ d+ Ç   (m+ z+ 
pñ  ¿2pñ  Äv .¢^àPàPàPÄN`     	Ú0‘ ¨+ r   () µ+ F NHF    ≤0‘ ‘+ Z   (È( ›+ b *h  í0‘ ¯+ B   (, , ( 2pñ  @v   	J 0  X @  + t< 4; 8 P  ‘ H, ≤  (Q, p, ( 2pñ  –2ò ¡:4F  pn( ê≤Æ™h¯:    % d 4  p  ‘ †, Ç   (m+ ©, 
ö 8|RD % d 4  p  ‘ ‘, Ç   (m+ ›, 
í 8|PD $ 4 Ú
‡p`P‘ - r   (- (- óW .( Rpñ  †2pñ  P¨©<ê6:   d	 4 RpX (   .  t7  d6  45  0 ‡P  ‘ x- r  (Å- §- 

|s `2 s r s : s A: s Å–‰Aä˙
A  ( 4t n p`P  ‘ ‘- b  (›- Ù- 
óW .( RºÃ  †6( Xi‹|   ≤0X P    4 “P
( $. (a' -. ^ H   
4 
≤pX P    4	 Rp
( \. (e. k. î\ b  0 x5 h6 n 	‡p`0P  ‘ ò. B  (°. Ω. 
pñ  A:pñ  ¡:pñ  ∞6( X`Ã 4N†Lôr     t 4 “P
( Ë. (a' Ò. í F  % t 4  P  ‘ / í   (' !/ ¨BBÑ   # #t* #d) #4( #" ‡–¿P  
( T/ (]/ •/ 
pñ  P:pñ  ‡2pñ  P2pñ  A“pñ  A:pñ  P2pñ  ‡2pñ  †2pñ  ¡:pñ  A:pñ  ¡2í d@ x@ t
N&N0.,>º v@ zL0>f 6å 4O L p  X P  ! T 4 r‡p`‘ 0 :   (πÁ 0 z! 4N H p`P  X 0  &	 40 ( ‡
–p`P  ‘ \0 :  (e0 ≠0 
0w  Å:0w  !:pñ  °rpñ  °>( bpñ  !:pñ  °:pñ  †¢pñ  †“»Y  † »Y  †2z :dHÇj§XxThj§Z⁄DlT™ 8   2 !dF !4E !> ‡¿pP  ‘ 1 ‚  (1 U1 ˆ\ *0w  °:0w  A:pñ  ‡jpñ  ¡:úu >( bpñ  A:pñ  ‡2pñ  †$ :hLå
""n,VUË¬ î! 4M J p  X @   4S P p  X p   4 “P‘ ƒ1 b   (Õ1 ﬂ1 
pñ  Ä6( Zpñ  @p N‰    Ç  X 0   # t 4 ÚP‘ 2 z   (2 *2 
pñ  ∞2pñ  p
é 6XN8    # t 4 ÚP‘ T2 z   (]2 d2 
pñ  ∞Ü 6¬  %	 4V N 
‡p`P  X `  	 	“P
( ú2 (a' •2 V H   Ç  X 8    b  X (    4 ÚpX p   ! T ‡p`0  X ê   “p`0X h    rp`0X 8    N p`0  X `   p`0  X `    	‡p`P0X p    íp`0X H    ≤p`0X X    4 íp`PX H    ¢p0  X H    í0X H   -
 Q ‡	–¿p`0P‘ ¯3 r  (a' 4 › h:    +	 P 	‡¿p`0P  ‘ 04 r  (a' 94 m h:     d 4 Úp
( \4 (m+ e4 $ pHP   ≤0X X    4 ÚpX x    d 4 íp‘ ∞4 B   (È π4 Ñ $®  4 ≤p`P‘ ‹4 R   (YÛ Â4 Ä $÷  d 4 íp‘ 5 B   (È 5 Ñ $é % t! 4   P  ‘ 85 “   (A5 Z5 
pñ  –2pñ  Ä2pñ  @öhu ¿Æ BB$VV    p0P  ‘ Ñ5 ≤   (ç5 †5 
|s P:|s P2pñ  –~\T     -
 o ‡	–¿p`0P‘ –5 b  (Ÿ5 w6 2¿Z *pñ  p2pñ  !ít ¡:pñ  A:pñ  ∞2pñ  p÷( ¬pñ  °:pñ  p2pñ  !:pñ  !>( `jpñ  ∞ıpñ  !Bpñ  p2pñ  °µpñ  !Bpñ  ∞2pñ  ¡:pñ  p2pñ  A:pñ  !:pñ  °P–$8ûUm
N<Jh\
0V¨
@N<*x`|
\ ."J$Äj&J($*J,:.:082H0‹22$   d	 4 Rp! 4 “
‡p`P‘ ¸6 j   (Ò  7 9 Ã¶    '
  ‡	–¿p`0P‘ 47 ‚   (=7 Ö7 
0w  ¡:0w  !:pñ  P2pñ  ê08F( h⁄pñ  ê6( Xbpñ  Pípñ  A:pñ  ‡2pñ  P&¶ê"é~@<((.@r4ín 2$ dS 4R N p  X `  %	 * 	‡¿p`0P  ‘ Ï7 J  (ı7 18 ( 2pñ  !:pñ  °:pñ  !:pñ  –2pñ  °:pñ  !:pñ  °>( `åÿ∏
,((p‹ .  7 &t∑ &d∂ &4¥ &Æ ‡–¿P  ‘ t8 b  (}8 ò8 
pñ  Ä:y  :Ät A:pñ  ¿˛ † y‡6¿ L& S p`P
0X Ä  %	  	‡¿p`0P  X ¿    ≤0‘ ¯8 R   (9 9 
4_ @d &J   ≤p`0
( $9 (-9 :9 
pñ  Ä6( X2 8\    d 4 “p
( \9 () e9 ä L6# d T 4 ≤p‘ å9 Z   (ï9 ß9 [ 2dy  @by  P
p D,∆ˆ   # d 4 “‡pP‘ ‘9 b   (›9 Í9 
pñ  Ä2pñ  @r >TPƒF  - t+ d* 4) $ ‡P  ‘  :   (): A: 
ús ê6( Zpñ  2 t ¿≤¸}u , d 4  ‡¿pP  ‘ t: ™   (}: ü: 
t A:t 2pñ  †6( Xbpñ  `êò† îjfHf¶fHV(f@Ç B  % t d 4 ≤PX X   % d 4  p  ‘ ¸: Ç   (m+ ; 
ú 8|RD % t 4  P  ‘ 0; ä   (ù& 9; 
å 6àV8  b	‡p`P0  X (    4 ≤P‘ x; R   (Å; à; 
 t pJ ¢d    ≤	‡¿p`0P‘ ∞; Z   (π; ∆; 
0w  Ä2pñ  @»¸e`  í‡p`P0‘ Ï; B   (È ı; d RF 	 ¬‡	–¿p`0P  
( < (·Â %< \ ˘é    % t 4  P  ‘ P< ™   (Y< Ç< 
pñ  P6( Zpñ  !>